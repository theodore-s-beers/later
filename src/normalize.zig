const std = @import("std");
const AutoHashMap = std.AutoHashMap;

const Collator = @import("collator").Collator;

// Jamo-related consts
const S_BASE: u32 = 0xAC00;
const L_BASE: u32 = 0x1100;
const V_BASE: u32 = 0x1161;
const T_BASE: u32 = 0x11A7;
const T_COUNT: u32 = 28;
const N_COUNT: u32 = 588;
const JAMO_LV = [_]u32{
    0xAC00, 0xAC1C, 0xAC38, 0xAC54, 0xAC70, 0xAC8C, 0xACA8, 0xACC4, 0xACE0, 0xACFC, 0xAD18,
    0xAD34, 0xAD50, 0xAD6C, 0xAD88, 0xADA4, 0xADC0, 0xADDC, 0xADF8, 0xAE14, 0xAE30, 0xAE4C,
    0xAE68, 0xAE84, 0xAEA0, 0xAEBC, 0xAED8, 0xAEF4, 0xAF10, 0xAF2C, 0xAF48, 0xAF64, 0xAF80,
    0xAF9C, 0xAFB8, 0xAFD4, 0xAFF0, 0xB00C, 0xB028, 0xB044, 0xB060, 0xB07C, 0xB098, 0xB0B4,
    0xB0D0, 0xB0EC, 0xB108, 0xB124, 0xB140, 0xB15C, 0xB178, 0xB194, 0xB1B0, 0xB1CC, 0xB1E8,
    0xB204, 0xB220, 0xB23C, 0xB258, 0xB274, 0xB290, 0xB2AC, 0xB2C8, 0xB2E4, 0xB300, 0xB31C,
    0xB338, 0xB354, 0xB370, 0xB38C, 0xB3A8, 0xB3C4, 0xB3E0, 0xB3FC, 0xB418, 0xB434, 0xB450,
    0xB46C, 0xB488, 0xB4A4, 0xB4C0, 0xB4DC, 0xB4F8, 0xB514, 0xB530, 0xB54C, 0xB568, 0xB584,
    0xB5A0, 0xB5BC, 0xB5D8, 0xB5F4, 0xB610, 0xB62C, 0xB648, 0xB664, 0xB680, 0xB69C, 0xB6B8,
    0xB6D4, 0xB6F0, 0xB70C, 0xB728, 0xB744, 0xB760, 0xB77C, 0xB798, 0xB7B4, 0xB7D0, 0xB7EC,
    0xB808, 0xB824, 0xB840, 0xB85C, 0xB878, 0xB894, 0xB8B0, 0xB8CC, 0xB8E8, 0xB904, 0xB920,
    0xB93C, 0xB958, 0xB974, 0xB990, 0xB9AC, 0xB9C8, 0xB9E4, 0xBA00, 0xBA1C, 0xBA38, 0xBA54,
    0xBA70, 0xBA8C, 0xBAA8, 0xBAC4, 0xBAE0, 0xBAFC, 0xBB18, 0xBB34, 0xBB50, 0xBB6C, 0xBB88,
    0xBBA4, 0xBBC0, 0xBBDC, 0xBBF8, 0xBC14, 0xBC30, 0xBC4C, 0xBC68, 0xBC84, 0xBCA0, 0xBCBC,
    0xBCD8, 0xBCF4, 0xBD10, 0xBD2C, 0xBD48, 0xBD64, 0xBD80, 0xBD9C, 0xBDB8, 0xBDD4, 0xBDF0,
    0xBE0C, 0xBE28, 0xBE44, 0xBE60, 0xBE7C, 0xBE98, 0xBEB4, 0xBED0, 0xBEEC, 0xBF08, 0xBF24,
    0xBF40, 0xBF5C, 0xBF78, 0xBF94, 0xBFB0, 0xBFCC, 0xBFE8, 0xC004, 0xC020, 0xC03C, 0xC058,
    0xC074, 0xC090, 0xC0AC, 0xC0C8, 0xC0E4, 0xC100, 0xC11C, 0xC138, 0xC154, 0xC170, 0xC18C,
    0xC1A8, 0xC1C4, 0xC1E0, 0xC1FC, 0xC218, 0xC234, 0xC250, 0xC26C, 0xC288, 0xC2A4, 0xC2C0,
    0xC2DC, 0xC2F8, 0xC314, 0xC330, 0xC34C, 0xC368, 0xC384, 0xC3A0, 0xC3BC, 0xC3D8, 0xC3F4,
    0xC410, 0xC42C, 0xC448, 0xC464, 0xC480, 0xC49C, 0xC4B8, 0xC4D4, 0xC4F0, 0xC50C, 0xC528,
    0xC544, 0xC560, 0xC57C, 0xC598, 0xC5B4, 0xC5D0, 0xC5EC, 0xC608, 0xC624, 0xC640, 0xC65C,
    0xC678, 0xC694, 0xC6B0, 0xC6CC, 0xC6E8, 0xC704, 0xC720, 0xC73C, 0xC758, 0xC774, 0xC790,
    0xC7AC, 0xC7C8, 0xC7E4, 0xC800, 0xC81C, 0xC838, 0xC854, 0xC870, 0xC88C, 0xC8A8, 0xC8C4,
    0xC8E0, 0xC8FC, 0xC918, 0xC934, 0xC950, 0xC96C, 0xC988, 0xC9A4, 0xC9C0, 0xC9DC, 0xC9F8,
    0xCA14, 0xCA30, 0xCA4C, 0xCA68, 0xCA84, 0xCAA0, 0xCABC, 0xCAD8, 0xCAF4, 0xCB10, 0xCB2C,
    0xCB48, 0xCB64, 0xCB80, 0xCB9C, 0xCBB8, 0xCBD4, 0xCBF0, 0xCC0C, 0xCC28, 0xCC44, 0xCC60,
    0xCC7C, 0xCC98, 0xCCB4, 0xCCD0, 0xCCEC, 0xCD08, 0xCD24, 0xCD40, 0xCD5C, 0xCD78, 0xCD94,
    0xCDB0, 0xCDCC, 0xCDE8, 0xCE04, 0xCE20, 0xCE3C, 0xCE58, 0xCE74, 0xCE90, 0xCEAC, 0xCEC8,
    0xCEE4, 0xCF00, 0xCF1C, 0xCF38, 0xCF54, 0xCF70, 0xCF8C, 0xCFA8, 0xCFC4, 0xCFE0, 0xCFFC,
    0xD018, 0xD034, 0xD050, 0xD06C, 0xD088, 0xD0A4, 0xD0C0, 0xD0DC, 0xD0F8, 0xD114, 0xD130,
    0xD14C, 0xD168, 0xD184, 0xD1A0, 0xD1BC, 0xD1D8, 0xD1F4, 0xD210, 0xD22C, 0xD248, 0xD264,
    0xD280, 0xD29C, 0xD2B8, 0xD2D4, 0xD2F0, 0xD30C, 0xD328, 0xD344, 0xD360, 0xD37C, 0xD398,
    0xD3B4, 0xD3D0, 0xD3EC, 0xD408, 0xD424, 0xD440, 0xD45C, 0xD478, 0xD494, 0xD4B0, 0xD4CC,
    0xD4E8, 0xD504, 0xD520, 0xD53C, 0xD558, 0xD574, 0xD590, 0xD5AC, 0xD5C8, 0xD5E4, 0xD600,
    0xD61C, 0xD638, 0xD654, 0xD670, 0xD68C, 0xD6A8, 0xD6C4, 0xD6E0, 0xD6FC, 0xD718, 0xD734,
    0xD750, 0xD76C, 0xD788,
};

pub fn makeNFD(coll: *Collator, input: *std.ArrayList(u32)) !void {
    if (try fcd(coll, input.items)) return;

    try decompose(coll, input);
    try reorder(coll, input);
}

fn fcd(coll: *Collator, input: []const u32) !bool {
    var prev_trail_cc: u8 = 0;

    for (input) |c| {
        if (c < 0x00C0) {
            prev_trail_cc = 0;
            continue;
        }

        if (c == 0x0F81 or (0xAC00 <= c and c <= 0xD7A3)) return false;

        const lead_cc, const trail_cc = blk: {
            if (try coll.getFCD(c)) |vals| {
                const bytes = std.mem.toBytes(std.mem.bigToNative(u16, vals));
                break :blk .{ bytes[0], bytes[1] };
            } else {
                const cc: u8 = try coll.getCCC(c) orelse 0;
                break :blk .{ cc, cc };
            }
        };

        if (lead_cc != 0 and lead_cc < prev_trail_cc) return false;

        prev_trail_cc = trail_cc;
    }

    return true;
}

fn decompose(coll: *Collator, input: *std.ArrayList(u32)) !void {
    var i: usize = 0;

    while (i < input.items.len) {
        const code_point = input.items[i];

        if (code_point < 0x00C0) {
            i += 1;
            continue;
        }

        if (0xAC00 <= code_point and code_point <= 0xD7A3) {
            const rep = try decomposeJamo(coll.alloc, code_point);
            try input.replaceRange(i, 1, rep.items);

            i += rep.items.len;
            continue;
        }

        if (try coll.getDecomp(code_point)) |decomp| {
            try input.replaceRange(i, 1, decomp);
            i += decomp.len;
            continue;
        }

        i += 1;
    }
}

fn decomposeJamo(alloc: std.mem.Allocator, s: u32) !std.ArrayList(u32) {
    const s_index = s - S_BASE;

    const lv = std.mem.indexOfScalar(u32, &JAMO_LV, s) != null;

    const l_index = s_index / N_COUNT;
    const v_index = (s_index % N_COUNT) / T_COUNT;

    if (lv) {
        const l_part = L_BASE + l_index;
        const v_part = V_BASE + v_index;

        var result = try std.ArrayList(u32).initCapacity(alloc, 2);
        try result.append(l_part);
        try result.append(v_part);

        return result;
    } else {
        const t_index = s_index % T_COUNT;

        const l_part = L_BASE + l_index;
        const v_part = V_BASE + v_index;
        const t_part = T_BASE + t_index;

        var result = try std.ArrayList(u32).initCapacity(alloc, 3);
        try result.append(l_part);
        try result.append(v_part);
        try result.append(t_part);

        return result;
    }
}

fn reorder(coll: *Collator, input: *std.ArrayList(u32)) !void {
    var n = input.items.len;

    while (n > 1) {
        var new_n: usize = 0;
        var i: usize = 1;

        while (i < n) {
            const ccc_b = try coll.getCCC(input.items[i]) orelse 0;
            if (ccc_b == 0) {
                i += 2;
                continue;
            }

            const ccc_a = try coll.getCCC(input.items[i - 1]) orelse 0;
            if (ccc_a == 0 or ccc_a <= ccc_b) {
                i += 1;
                continue;
            }

            std.mem.swap(u32, &input.items[i - 1], &input.items[i]);

            new_n = i;
            i += 1;
        }

        n = new_n;
    }
}
